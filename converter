#! local/bin/python
# -*- coding: utf-8 -*-

from bs4 import BeautifulSoup
from halo import Halo
import getopt
import hashlib
import music21
import os.path
import sys
import tempfile

from postprocess import (checkForPreprocessor, selectPreprocessors,
                         reduceEventsAndMeta)
from postprocess.normalize import NormalizePostprocessor

from util import extract
from util import transform

"""
Convert a MusicXML file generated by Guitar Pro into MIDI files, one per each track, optimized for Reaper+RealEight guitar synth.
Note that this program assumes your RealEight is set up in Direct (MIDI) mode, as it makes use of MIDI channel changes to create
certain performance effects (like palm mutes and vibrato).

"""

TICKS_PER_QUARTER_NOTE = 1024

def spin(text):
    frames = ["𝄞", "𝄢", "♪", "♫"]
    spinner = Halo(text=text, animation="marquee",
                   spinner={"interval": 500, "frames": frames})
    spinner.start()
    return spinner

def usage():
    print("Usage: converter [-h/--help] [-v/--verbose] [-f/--force] [-p postprocessor] [-n/-normalize] XML-filename", file=sys.stderr)
    sys.exit(-1)

def main(args):
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hvfp:n", ["help", "verbose", "force", "postprocessor=", "normalize"])
    except getopt.GetoptError as err:
        print(err)
        usage()

    verbose = False
    force = False
    postproc = None
    normalize = False

    for o, a in opts:
        if o == "-v":
            verbose = True
        elif o == "-f":
            force = True
        elif o == "-p":
            assert checkForPreprocessor(a), "'{}' is not a recognized postprocessor".format(a)
            postproc = a
        elif o == "-n":
            normalize = True
        else:
            assert False, "illegal option"

    if len(args) != 1:
        usage()

    postprocs = selectPreprocessors(postproc)
    if normalize:
        postprocs = postprocs + (NormalizePostprocessor,)

    filename = args[0]

    if not os.path.isfile(filename):
        print("{} is not a valid file location".format(filename), file=sys.stderr)
        sys.exit(-1)

    directory = os.path.dirname(filename)

    spinner = None
    score = None

    with open(filename, "r") as musicXMLFile:
        rawXML = musicXMLFile.read()

        # To speed up consecutive calls, we try to cache the most
        # time-intensive work: parsing from XML and into music21
        h = hashlib.sha1()
        h.update(str(rawXML).encode('utf-8'))
        sha1 = h.hexdigest()
        base = os.path.basename(filename)
        prefix, suffix = os.path.splitext(base)
        cachename = os.path.join(tempfile.gettempdir(),
                                 "{}__{}{}".format(prefix, sha1, suffix))

        if verbose:
            spinner = spin("Fetching {} from cache".format(filename))

        try:
            if force:
                raise Exception("Force invoked")
            score = music21.converter.thaw(cachename)
            if verbose:
                spinner.succeed()
        except Exception as exc:
            if verbose:
                spinner.text = "Importing and parsing {}".format(filename)

            # First things first: we need to annotate the MusicXML file
            # in ways that Music21 will recognize.
            markup = BeautifulSoup(rawXML, "xml")

            if verbose:
                spinner.succeed()


            # Now we can prepare the markup, and proceed with M21 extraction
            if verbose:
                spinner = spin("Preparing music data for extraction and transformation")

            extract.standardizeExpressions(markup)
            score = music21.converter.parseData(str(markup), format="musicxml")

            # This is a good place to commit the cachefile
            music21.converter.freeze(score, fmt="pickle", fp=cachename)

            if verbose:
                spinner.succeed()

        # Create a tempo track
        if verbose:
            spinner = spin("Detecting tempos")

        tempos = extract.getStreamTempo(score, TICKS_PER_QUARTER_NOTE,
                                        verbose=verbose)
        tempoTrack = music21.midi.MidiTrack(0)
        tempoOffset = 0
        for offsetKey in sorted(tempos.keys()):
            bpm = tempos[offsetKey]

            if offsetKey > tempoOffset:
                delta = music21.midi.DeltaTime(tempoTrack)
                delta.time = offsetKey - tempoOffset
                tempoTrack.events.append(delta)
                tempoOffset = offsetKey

            mark = music21.tempo.MetronomeMark(number=bpm)
            tempoEvents = music21.midi.translate.tempoToMidiEvents(mark)
            tempoTrack.events.extend(tempoEvents)
            tempoTrack.channel = 0

        if verbose:
            spinner.succeed()

        # Now onto the actual notes
        partNames = set()

        for part in score.parts:
            partName = part.partName
            if partName not in partNames:
                partNames.add(partName)

                if verbose:
                    spinner = spin("Extracting the '{}' part".format(partName))

                track = music21.midi.MidiTrack(1)
                eventsAndMeta = transform.createMIDIEvents(part,
                                                           track,
                                                           verbose=verbose)

                for processor in postprocs:
                    eventsAndMeta = processor().run(eventsAndMeta)
                track.events = reduceEventsAndMeta(eventsAndMeta)

                midiFile = music21.midi.MidiFile()
                midiFile.tracks.append(track)
                midiFile.tracks.append(tempoTrack)

                midiFile.open(os.path.join(directory, "{}.mid".format(partName)), "wb")
                midiFile.write()
                midiFile.close()

                if verbose:
                    spinner.succeed()

if __name__ == "__main__":
   main(sys.argv[1:])
